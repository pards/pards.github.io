---
layout: post
title: Writing deterministic tests
categories:
- Software Development
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _syntaxhighlighter_encoded: '1'
  _aioseop_description: Non-deterministic unit tests are like kryptonite for an automated
    build. They cause intermittent build failures and the development team start to
    ignore the failing build. This is a Bad Thing.
  _aioseop_keywords: unit test, junit, thread.sleep, deterministic testing, multi-threaded
    testing, junit multi-threaded
  _aioseop_title: Writing deterministic tests
author:
  login: craig
  email: craigpardey@gmail.com
  display_name: craig
  first_name: Craig
  last_name: Pardey
---
<p>Non-deterministic unit tests are like kryptonite for an automated build. They cause intermittent build failures and the development team becomes accustomed to ignoring a failing build. This is a Bad Thing.</p>
<p>Thread.sleep(x) in a unit test is a recipe for non-deterministic behaviour.  Think about what happens when this test is run on a slow machine. How big does X need to be?</p>
<p>I often see this anti-pattern in multi-threaded code where the test case is waiting for some asynchronous task to complete, and the test case has to guess at how long the task will take, and then asserts on some condition that the task was supposed to change.</p>
<p>The other factor to consider is that Thread.sleep(x) will always wait X milliseconds even if the task finished earlier than you expected.  The more of these you add, the slower your test suite will be.</p>
<p>You need to use deterministic waits.</p>
<p>By that, I mean using a callback method plus wait()/notify().  </p>
<p>Consider the following example:</p>
<p>[java]<br />
@Test<br />
public void testSomeAsynchCode() throws Exception<br />
{<br />
	AsynchObj asynchObj = new AsynchObj();<br />
	final Object lock = new Object();<br />
	asynchObj.addListener(new AsynchListener()<br />
	{<br />
		@Override<br />
		public void asynchCodeDone()<br />
		{<br />
			synchronized (lock)<br />
			{<br />
				System.out.println(&quot;Listener notified&quot;);<br />
				lock.notify();<br />
			}<br />
		}<br />
	});</p>
<p>	synchronized (lock)<br />
	{<br />
		System.out.println(&quot;Running asynch code&quot;);<br />
		asynchObj.asynchCode();<br />
		lock.wait(TIMEOUT);<br />
		System.out.println(&quot;Test notified&quot;);<br />
	}<br />
	assertEquals(2, asynchObj.getSomeValue());<br />
}<br />
[/java]</p>
<p>[java]<br />
public interface AsynchListener<br />
{<br />
	void asynchCodeDone();<br />
}<br />
[/java]</p>
<p>[java]<br />
public class AsynchObj<br />
{<br />
	private final int MAX_WAIT = 4000;<br />
	private int someValue;<br />
	private Set&lt;AsynchListener&gt; listeners = new HashSet&lt;AsynchListener&gt;();<br />
	private ExecutorService executor = Executors.newCachedThreadPool();</p>
<p>	public void addListener(AsynchListener listener)<br />
	{<br />
		listeners.add(listener);<br />
	}</p>
<p>	public void asynchCode()<br />
	{<br />
		executor.submit(new AsynchObjTask());<br />
	}</p>
<p>	class AsynchObjTask implements Runnable<br />
	{<br />
		private Random r = new Random();<br />
		public void run()<br />
		{<br />
			randomWait();<br />
			setSomeValue(2);<br />
			for (AsynchListener listener : listeners)<br />
			{<br />
				listener.asynchCodeDone();<br />
			}<br />
		}</p>
<p>		private void randomWait()<br />
		{<br />
			int wait = r.nextInt(MAX_WAIT);<br />
			try<br />
			{<br />
				System.out.println(String.format(&quot;Waiting for %d ms&quot;, wait));<br />
				Thread.sleep(wait);<br />
			}<br />
			catch (InterruptedException e)<br />
			{<br />
			}<br />
		}<br />
	}</p>
<p>	public void setSomeValue(int x)<br />
	{<br />
		this.someValue = x;<br />
	}</p>
<p>	public int getSomeValue()<br />
	{<br />
		return this.someValue;<br />
	}<br />
}<br />
[/java]</p>
<p>Here's the full <a href="http://craigpardey.com/wp/wp-content/uploads/2013/10/asynch.zip">source code</a>.</p>
<p>In this example, AsynchObj will notify the test as soon as it has run the asynchronous code. The test case will immediately run the assertion.</p>
<p>This will run exactly the same way on a slow machine as it will on a fast machine. It will pass (or fail) consistently.</p>
<p>Say goodbye to intermittent build failures!</p>
