---
layout: post
title: Synchronized code in distributed systems
categories:
- Software Development
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _aioseop_title: Synchronized code in distributed systems
  _aioseop_description: Synchronized code in distributed systems requires the use
    of a synchronization point that is used by all members of the cluster.  The simplest
    solution is to use the database.
  _aioseop_keywords: Java synchronization, synchronize cluster
  Title: Synchronized code in distributed systems
  Description: Synchronized code in distributed systems requires the use of a synchronization
    point that is used by all members of the cluster.  The simplest solution is to
    use the database.
  Keywords: Java synchronization, synchronize cluster
author:
  login: craig
  email: craigpardey@gmail.com
  display_name: craig
  first_name: Craig
  last_name: Pardey
---
<p>I encountered some code recently where a GUI client was listening for Object updates from a multi-threaded server, and it was using the version number on the Object to determine whether the incoming Object was the latest version.  The server incremented the version of the Object by inserting a new row into a table in the database and using the primary key as the version number.</p>
<p>Now consider the case multi-threaded case where two threads, T1 and T2, are making updates to the Object. </p>
<ol>
<li>Both threads start a transaction.</li>
<li>T1 increments the version to v1.</li>
<li>T2 increments the version to v2.</li>
<li>T2 commits and sends the notification to the client.</li>
<li>T1 commits and sends its notification to the client.</li>
</ol>
<p>The GUI ignores the update from T1 because it already has v2 of the Object from T2.  The problem was that the changes from T1 were not included in the update from T2 because T1 had not committed its database changes.</p>
<p>The underlying problem here is that there is no synchronization around incrementing the version.  There are several ways of solving this problem:</p>
<p><strong>Option 1</strong>: use Java's synchronized keyword<br />
In this solution the version number would be incremented in a synchronized block, using the Object instance as the lock on which to synchronize.</p>
<pre name="code" class="java">
synchronized(myObject) {
  myObject.setVersion( myObject.getVersion() + 1);
}
</pre>
<p>This method works in a multi-threaded environment but does not work when the application is clustered across multiple servers.</p>
<p><strong>Option 2</strong>: use the database as the synchronization point.<br />
In this solution the version number is moved from its own table to the master record, and the field is updated when we need to increment the version. However, there is a pitfall that needs to be avoided for this to work as expected.</p>
<p>The incorrect way to do this is to increment the value in Java and save it.</p>
<pre name="code" class="java">
  String sql = "update my_obj set version = ? where id = ?";
  ...
  stmt.setInt( idx++, o.getVersion()+1);
  stmt.setInt( idx++, o.getId());
  stmt.execute();
</pre>
<p>The problem here is that different threads could write the same version number when they should have incremented it.  Consider this scenario:</p>
<ol>
<li>Both threads start a transaction.</li>
<li>T1 reads the Object (v1).</li>
<li>T2 reads the Object (v1).</li>
<li>T1 increments the version to v2.</li>
<li>T2 increments the version to v2.</li>
</ol>
<p>T2 should have incremented the version to v3 but T1 hadn't committed its update when T2 read the record from the database.</p>
<p>The correct way to do this is to update the record in place because this forces all threads across all clustered servers to get a write lock on a single record in the database, and the value that they are incrementing is always the latest.  Each thread will block until the previous one has committed its change.</p>
<pre name="code" class="java">
  String sql = "update my_obj set version = version + 1 where id = ?";
  ...
  stmt.setInt( idx++, o.getId());
  stmt.execute();
</pre>
