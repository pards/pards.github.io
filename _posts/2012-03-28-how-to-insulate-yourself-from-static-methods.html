---
layout: post
title: How to insulate yourself from static methods
categories:
- Software Development
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _aioseop_description: How to unit test static methods calls in 3rd party libraries
  _aioseop_keywords: unit test, static unit test
  Title: Unit testing static methods
  Description: How to unit test static methods calls in 3rd party libraries
  Keywords: unit test, junit, static unit test
  _aioseop_title: Unit test static methods in 3rd party libraries
author:
  login: craig
  email: craigpardey@gmail.com
  display_name: craig
  first_name: Craig
  last_name: Pardey
---
<p>Sometimes your code needs to call a static method in a 3rd party library and unit testing  suddenly becomes difficult, particularly when that static method requires context in order to work.</p>
<p>Enter the insulating class (also known as a Facade).</p>
<ol>
<li>Create a new interface that declares a method with the same signature as the static method you want to delegate to</li>
<li>Create a new Facade class that implements the interface</li>
<li>Replace the calls to the static method with calls to your new Facade class</li>
</ol>
<p>Let's assume that the method you need to call looks like this</p>
<pre name="code" class="java">
public class ThirdPartyValueComputer {
  public static int computeValue(SomeObject param, SomeOtherObject param){
    ....
  }
}
</pre>
<p>If you put this call into another class with an interface then you will be able to use mock objects to test your code.</p>
<pre name="code" class="java">
public interface IValueComputer {
  int computeValue(SomeObject p1, SomeOtherObject p2);
}

public class ValueComputerFacade implements IValueComputer {
  @Override
  public int computeValue(SomeObject p1, SomeOtherObject p2){
    return ThirdPartyValueComputer.computeValue(SomeObject p1, SomeOtherObject p2);
  }
}

public interface ISomeService {
  int calculate(SomeObject p1, SomeOtherObject p2);
}

public class SomeService implements ISomeService {
  private IValueComputer valueComputer;
  public void setValueComputer(IValueComputer c){
    this.valueComputer = c;
  }

  @Override
  public int calculate(SomeObject p1, SomeOtherObject p2) {
    int computedValue = valueComputer.computeValue(p1, p2);
    // Now perform the logic you need to test
    int result = ...;
    return result;
  }
}
</pre>
<p>The service is configured in Spring as follows</p>
<pre name="code" class="xml">
  <bean id="valueComputer" class="com.acme.ValueComputerFacade">
  </bean>
  <bean id="someService" class="com.acme.SomeService" p:valuecomputer-ref="valueComputer">
  </bean>
</pre>
<p>Now that you've created and configured your facade, you can write tests for the service class as follows</p>
<pre name="code" class="java">
Mockery context = new Mockery();

@Test
public void testCalculate() throws Exception {
  final SomeObject p1 = new SomeObject();
  final SomeOtherObject p2 = new SomeOtherObject();

  IValueComputer valueComputer = context.mock(IValueComputer.class);
  SomeService service = new SomeService();
  service.setValueComputer(valueComputer);
  
  context.checking(new Expectations() {{
    oneOf(valueComputer).computeValue(p1, p2))
    will(Expectations.returnValue(1));
  }});

  int result = service.calculate(p1, p2);
  assertEquals(1, result);
}
</pre>
